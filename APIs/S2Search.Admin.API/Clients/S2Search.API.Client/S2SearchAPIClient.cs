// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace S2SearchAPI
{
    // Data plane generated client.
    /// <summary> The S2SearchAPI service client. </summary>
    public partial class S2SearchAPIClient
    {
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of S2SearchAPIClient. </summary>
        public S2SearchAPIClient() : this(new Uri(""), new S2SearchAPIClientOptions())
        {
        }

        /// <summary> Initializes a new instance of S2SearchAPIClient. </summary>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> is null. </exception>
        public S2SearchAPIClient(Uri endpoint, S2SearchAPIClientOptions options)
        {
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            options ??= new S2SearchAPIClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), Array.Empty<HttpPipelinePolicy>(), new ResponseClassifier());
            _endpoint = endpoint;
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetConfigAsync(Guid,RequestContext)']/*" />
        public virtual async Task<Response> GetConfigAsync(Guid searchIndexId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetConfig");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetConfigRequest(searchIndexId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetConfig(Guid,RequestContext)']/*" />
        public virtual Response GetConfig(Guid searchIndexId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetConfig");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetConfigRequest(searchIndexId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "text/json". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='UpdateConfigAsync(RequestContent,ContentType,RequestContext)']/*" />
        public virtual async Task<Response> UpdateConfigAsync(RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.UpdateConfig");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateConfigRequest(content, contentType, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "text/json". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='UpdateConfig(RequestContent,ContentType,RequestContext)']/*" />
        public virtual Response UpdateConfig(RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.UpdateConfig");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateConfigRequest(content, contentType, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerEndpoint"> The String to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="customerEndpoint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="customerEndpoint"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetSearchIndexQueryCredentialsAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> GetSearchIndexQueryCredentialsAsync(string customerEndpoint, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(customerEndpoint, nameof(customerEndpoint));

            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetSearchIndexQueryCredentials");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSearchIndexQueryCredentialsRequest(customerEndpoint, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerEndpoint"> The String to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="customerEndpoint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="customerEndpoint"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetSearchIndexQueryCredentials(string,RequestContext)']/*" />
        public virtual Response GetSearchIndexQueryCredentials(string customerEndpoint, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(customerEndpoint, nameof(customerEndpoint));

            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetSearchIndexQueryCredentials");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSearchIndexQueryCredentialsRequest(customerEndpoint, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerEndpoint"> The String to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="customerEndpoint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="customerEndpoint"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetThemeAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> GetThemeAsync(string customerEndpoint, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(customerEndpoint, nameof(customerEndpoint));

            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetTheme");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetThemeRequest(customerEndpoint, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerEndpoint"> The String to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="customerEndpoint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="customerEndpoint"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetTheme(string,RequestContext)']/*" />
        public virtual Response GetTheme(string customerEndpoint, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(customerEndpoint, nameof(customerEndpoint));

            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetTheme");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetThemeRequest(customerEndpoint, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerEndpoint"> The String to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="customerEndpoint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="customerEndpoint"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetSearchConfigurationAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> GetSearchConfigurationAsync(string customerEndpoint, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(customerEndpoint, nameof(customerEndpoint));

            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetSearchConfiguration");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSearchConfigurationRequest(customerEndpoint, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerEndpoint"> The String to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="customerEndpoint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="customerEndpoint"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetSearchConfiguration(string,RequestContext)']/*" />
        public virtual Response GetSearchConfiguration(string customerEndpoint, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(customerEndpoint, nameof(customerEndpoint));

            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetSearchConfiguration");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSearchConfigurationRequest(customerEndpoint, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="category"> The String to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="category"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="category"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetGenericSynonymsAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> GetGenericSynonymsAsync(string category, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(category, nameof(category));

            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetGenericSynonyms");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetGenericSynonymsRequest(category, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="category"> The String to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="category"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="category"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetGenericSynonyms(string,RequestContext)']/*" />
        public virtual Response GetGenericSynonyms(string category, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(category, nameof(category));

            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetGenericSynonyms");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetGenericSynonymsRequest(category, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetCustomerAsync(Guid,RequestContext)']/*" />
        public virtual async Task<Response> GetCustomerAsync(Guid customerId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetCustomer");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetCustomerRequest(customerId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetCustomer(Guid,RequestContext)']/*" />
        public virtual Response GetCustomer(Guid customerId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetCustomer");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetCustomerRequest(customerId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetCustomerAndSearchIndexesAsync(Guid,RequestContext)']/*" />
        public virtual async Task<Response> GetCustomerAndSearchIndexesAsync(Guid customerId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetCustomerAndSearchIndexes");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetCustomerAndSearchIndexesRequest(customerId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetCustomerAndSearchIndexes(Guid,RequestContext)']/*" />
        public virtual Response GetCustomerAndSearchIndexes(Guid customerId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetCustomerAndSearchIndexes");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetCustomerAndSearchIndexesRequest(customerId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetDashboardSummaryAsync(Guid,RequestContext)']/*" />
        public virtual async Task<Response> GetDashboardSummaryAsync(Guid customerId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetDashboardSummary");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDashboardSummaryRequest(customerId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetDashboardSummary(Guid,RequestContext)']/*" />
        public virtual Response GetDashboardSummary(Guid customerId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetDashboardSummary");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDashboardSummaryRequest(customerId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "text/json". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='CreateUserAsync(Guid,Guid,RequestContent,ContentType,RequestContext)']/*" />
        public virtual async Task<Response> CreateUserAsync(Guid customerId, Guid searchIndexId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.CreateUser");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateUserRequest(customerId, searchIndexId, content, contentType, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "text/json". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='CreateUser(Guid,Guid,RequestContent,ContentType,RequestContext)']/*" />
        public virtual Response CreateUser(Guid customerId, Guid searchIndexId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.CreateUser");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateUserRequest(customerId, searchIndexId, content, contentType, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="username"> The String to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="username"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="username"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='DeleteUserAsync(Guid,Guid,string,RequestContext)']/*" />
        public virtual async Task<Response> DeleteUserAsync(Guid customerId, Guid searchIndexId, string username, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(username, nameof(username));

            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.DeleteUser");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteUserRequest(customerId, searchIndexId, username, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="username"> The String to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="username"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="username"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='DeleteUser(Guid,Guid,string,RequestContext)']/*" />
        public virtual Response DeleteUser(Guid customerId, Guid searchIndexId, string username, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(username, nameof(username));

            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.DeleteUser");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteUserRequest(customerId, searchIndexId, username, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "text/json". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='UpdateUserStatusAsync(Guid,Guid,RequestContent,ContentType,RequestContext)']/*" />
        public virtual async Task<Response> UpdateUserStatusAsync(Guid customerId, Guid searchIndexId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.UpdateUserStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateUserStatusRequest(customerId, searchIndexId, content, contentType, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "text/json". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='UpdateUserStatus(Guid,Guid,RequestContent,ContentType,RequestContext)']/*" />
        public virtual Response UpdateUserStatus(Guid customerId, Guid searchIndexId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.UpdateUserStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateUserStatusRequest(customerId, searchIndexId, content, contentType, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "text/json". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='UpdateUserPasswordAsync(Guid,Guid,RequestContent,ContentType,RequestContext)']/*" />
        public virtual async Task<Response> UpdateUserPasswordAsync(Guid customerId, Guid searchIndexId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.UpdateUserPassword");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateUserPasswordRequest(customerId, searchIndexId, content, contentType, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "text/json". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='UpdateUserPassword(Guid,Guid,RequestContent,ContentType,RequestContext)']/*" />
        public virtual Response UpdateUserPassword(Guid customerId, Guid searchIndexId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.UpdateUserPassword");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateUserPasswordRequest(customerId, searchIndexId, content, contentType, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetCredentialsAsync(Guid,Guid,RequestContext)']/*" />
        public virtual async Task<Response> GetCredentialsAsync(Guid customerId, Guid searchIndexId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetCredentials");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetCredentialsRequest(customerId, searchIndexId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetCredentials(Guid,Guid,RequestContext)']/*" />
        public virtual Response GetCredentials(Guid customerId, Guid searchIndexId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetCredentials");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetCredentialsRequest(customerId, searchIndexId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetLatestFeedConfigurationAsync(Guid,Guid,RequestContext)']/*" />
        public virtual async Task<Response> GetLatestFeedConfigurationAsync(Guid customerId, Guid searchIndexId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetLatestFeedConfiguration");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLatestFeedConfigurationRequest(customerId, searchIndexId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetLatestFeedConfiguration(Guid,Guid,RequestContext)']/*" />
        public virtual Response GetLatestFeedConfiguration(Guid customerId, Guid searchIndexId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetLatestFeedConfiguration");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLatestFeedConfigurationRequest(customerId, searchIndexId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "text/json". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='SaveFeedConfigurationAsync(Guid,Guid,RequestContent,ContentType,RequestContext)']/*" />
        public virtual async Task<Response> SaveFeedConfigurationAsync(Guid customerId, Guid searchIndexId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.SaveFeedConfiguration");
            scope.Start();
            try
            {
                using HttpMessage message = CreateSaveFeedConfigurationRequest(customerId, searchIndexId, content, contentType, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "text/json". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='SaveFeedConfiguration(Guid,Guid,RequestContent,ContentType,RequestContext)']/*" />
        public virtual Response SaveFeedConfiguration(Guid customerId, Guid searchIndexId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.SaveFeedConfiguration");
            scope.Start();
            try
            {
                using HttpMessage message = CreateSaveFeedConfigurationRequest(customerId, searchIndexId, content, contentType, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='UploadFeedFileAsync(Guid,Guid,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UploadFeedFileAsync(Guid customerId, Guid searchIndexId, RequestContent content, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.UploadFeedFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUploadFeedFileRequest(customerId, searchIndexId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='UploadFeedFile(Guid,Guid,RequestContent,RequestContext)']/*" />
        public virtual Response UploadFeedFile(Guid customerId, Guid searchIndexId, RequestContent content, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.UploadFeedFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUploadFeedFileRequest(customerId, searchIndexId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetKeysAsync(Guid,Guid,RequestContext)']/*" />
        public virtual async Task<Response> GetKeysAsync(Guid customerId, Guid searchIndexId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetKeys");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetKeysRequest(customerId, searchIndexId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetKeys(Guid,Guid,RequestContext)']/*" />
        public virtual Response GetKeys(Guid customerId, Guid searchIndexId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetKeys");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetKeysRequest(customerId, searchIndexId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "text/json". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='CreateKeysAsync(Guid,Guid,RequestContent,ContentType,RequestContext)']/*" />
        public virtual async Task<Response> CreateKeysAsync(Guid customerId, Guid searchIndexId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.CreateKeys");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateKeysRequest(customerId, searchIndexId, content, contentType, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "text/json". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='CreateKeys(Guid,Guid,RequestContent,ContentType,RequestContext)']/*" />
        public virtual Response CreateKeys(Guid customerId, Guid searchIndexId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.CreateKeys");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateKeysRequest(customerId, searchIndexId, content, contentType, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "text/json". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='DeleteKeysAsync(Guid,Guid,RequestContent,ContentType,RequestContext)']/*" />
        public virtual async Task<Response> DeleteKeysAsync(Guid customerId, Guid searchIndexId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.DeleteKeys");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteKeysRequest(customerId, searchIndexId, content, contentType, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "text/json". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='DeleteKeys(Guid,Guid,RequestContent,ContentType,RequestContext)']/*" />
        public virtual Response DeleteKeys(Guid customerId, Guid searchIndexId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.DeleteKeys");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteKeysRequest(customerId, searchIndexId, content, contentType, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetNotificationRulesAsync(Guid,Guid,RequestContext)']/*" />
        public virtual async Task<Response> GetNotificationRulesAsync(Guid customerId, Guid searchIndexId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetNotificationRules");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetNotificationRulesRequest(customerId, searchIndexId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetNotificationRules(Guid,Guid,RequestContext)']/*" />
        public virtual Response GetNotificationRules(Guid customerId, Guid searchIndexId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetNotificationRules");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetNotificationRulesRequest(customerId, searchIndexId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "text/json". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='CreateNotificationRuleAsync(Guid,Guid,RequestContent,ContentType,RequestContext)']/*" />
        public virtual async Task<Response> CreateNotificationRuleAsync(Guid customerId, Guid searchIndexId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.CreateNotificationRule");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateNotificationRuleRequest(customerId, searchIndexId, content, contentType, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "text/json". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='CreateNotificationRule(Guid,Guid,RequestContent,ContentType,RequestContext)']/*" />
        public virtual Response CreateNotificationRule(Guid customerId, Guid searchIndexId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.CreateNotificationRule");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateNotificationRuleRequest(customerId, searchIndexId, content, contentType, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="notificationRuleId"> The Int32 to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetNotificationRuleByIdAsync(Guid,Guid,int,RequestContext)']/*" />
        public virtual async Task<Response> GetNotificationRuleByIdAsync(Guid customerId, Guid searchIndexId, int notificationRuleId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetNotificationRuleById");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetNotificationRuleByIdRequest(customerId, searchIndexId, notificationRuleId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="notificationRuleId"> The Int32 to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetNotificationRuleById(Guid,Guid,int,RequestContext)']/*" />
        public virtual Response GetNotificationRuleById(Guid customerId, Guid searchIndexId, int notificationRuleId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetNotificationRuleById");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetNotificationRuleByIdRequest(customerId, searchIndexId, notificationRuleId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="notificationRuleId"> The Int32 to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='DeleteNotificationRuleAsync(Guid,Guid,int,RequestContext)']/*" />
        public virtual async Task<Response> DeleteNotificationRuleAsync(Guid customerId, Guid searchIndexId, int notificationRuleId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.DeleteNotificationRule");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteNotificationRuleRequest(customerId, searchIndexId, notificationRuleId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="notificationRuleId"> The Int32 to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='DeleteNotificationRule(Guid,Guid,int,RequestContext)']/*" />
        public virtual Response DeleteNotificationRule(Guid customerId, Guid searchIndexId, int notificationRuleId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.DeleteNotificationRule");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteNotificationRuleRequest(customerId, searchIndexId, notificationRuleId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="page"> The Int32 to use. </param>
        /// <param name="pageSize"> The Int32 to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetNotificationsAsync(Guid,Guid,int?,int?,RequestContext)']/*" />
        public virtual async Task<Response> GetNotificationsAsync(Guid customerId, Guid searchIndexId, int? page = null, int? pageSize = null, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetNotifications");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetNotificationsRequest(customerId, searchIndexId, page, pageSize, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="page"> The Int32 to use. </param>
        /// <param name="pageSize"> The Int32 to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetNotifications(Guid,Guid,int?,int?,RequestContext)']/*" />
        public virtual Response GetNotifications(Guid customerId, Guid searchIndexId, int? page = null, int? pageSize = null, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetNotifications");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetNotificationsRequest(customerId, searchIndexId, page, pageSize, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerEndpoint"> The String to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="customerEndpoint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="customerEndpoint"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='QueryCredentialsAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> QueryCredentialsAsync(string customerEndpoint, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(customerEndpoint, nameof(customerEndpoint));

            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.QueryCredentials");
            scope.Start();
            try
            {
                using HttpMessage message = CreateQueryCredentialsRequest(customerEndpoint, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerEndpoint"> The String to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="customerEndpoint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="customerEndpoint"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='QueryCredentials(string,RequestContext)']/*" />
        public virtual Response QueryCredentials(string customerEndpoint, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(customerEndpoint, nameof(customerEndpoint));

            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.QueryCredentials");
            scope.Start();
            try
            {
                using HttpMessage message = CreateQueryCredentialsRequest(customerEndpoint, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="fullResource"> The Boolean to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetSearchIndexAsync(Guid,Guid,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetSearchIndexAsync(Guid customerId, Guid searchIndexId, bool? fullResource = null, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetSearchIndex");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSearchIndexRequest(customerId, searchIndexId, fullResource, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="fullResource"> The Boolean to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetSearchIndex(Guid,Guid,bool?,RequestContext)']/*" />
        public virtual Response GetSearchIndex(Guid customerId, Guid searchIndexId, bool? fullResource = null, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetSearchIndex");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSearchIndexRequest(customerId, searchIndexId, fullResource, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='DeleteSearchIndexAsync(Guid,Guid,RequestContext)']/*" />
        public virtual async Task<Response> DeleteSearchIndexAsync(Guid customerId, Guid searchIndexId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.DeleteSearchIndex");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteSearchIndexRequest(customerId, searchIndexId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='DeleteSearchIndex(Guid,Guid,RequestContext)']/*" />
        public virtual Response DeleteSearchIndex(Guid customerId, Guid searchIndexId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.DeleteSearchIndex");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteSearchIndexRequest(customerId, searchIndexId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="friendlyName"> The String to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="friendlyName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="friendlyName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetSearchIndexByNameAsync(Guid,string,RequestContext)']/*" />
        public virtual async Task<Response> GetSearchIndexByNameAsync(Guid customerId, string friendlyName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(friendlyName, nameof(friendlyName));

            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetSearchIndexByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSearchIndexByNameRequest(customerId, friendlyName, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="friendlyName"> The String to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="friendlyName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="friendlyName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetSearchIndexByName(Guid,string,RequestContext)']/*" />
        public virtual Response GetSearchIndexByName(Guid customerId, string friendlyName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(friendlyName, nameof(friendlyName));

            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetSearchIndexByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSearchIndexByNameRequest(customerId, friendlyName, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetSearchIndexPricingAsync(Guid,RequestContext)']/*" />
        public virtual async Task<Response> GetSearchIndexPricingAsync(Guid customerId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetSearchIndexPricing");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSearchIndexPricingRequest(customerId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetSearchIndexPricing(Guid,RequestContext)']/*" />
        public virtual Response GetSearchIndexPricing(Guid customerId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetSearchIndexPricing");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSearchIndexPricingRequest(customerId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "text/json". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='CreateSearchIndexAsync(Guid,RequestContent,ContentType,RequestContext)']/*" />
        public virtual async Task<Response> CreateSearchIndexAsync(Guid customerId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.CreateSearchIndex");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateSearchIndexRequest(customerId, content, contentType, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "text/json". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='CreateSearchIndex(Guid,RequestContent,ContentType,RequestContext)']/*" />
        public virtual Response CreateSearchIndex(Guid customerId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.CreateSearchIndex");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateSearchIndexRequest(customerId, content, contentType, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetSearchInsightsSummaryAsync(Guid,Guid,RequestContext)']/*" />
        public virtual async Task<Response> GetSearchInsightsSummaryAsync(Guid customerId, Guid searchIndexId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetSearchInsightsSummary");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSearchInsightsSummaryRequest(customerId, searchIndexId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetSearchInsightsSummary(Guid,Guid,RequestContext)']/*" />
        public virtual Response GetSearchInsightsSummary(Guid customerId, Guid searchIndexId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetSearchInsightsSummary");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSearchInsightsSummaryRequest(customerId, searchIndexId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="reportName"> The String to use. </param>
        /// <param name="dateFrom"> The DateTimeISO8601 to use. </param>
        /// <param name="dateTo"> The DateTimeISO8601 to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="reportName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="reportName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetChartByReportNameAsync(Guid,Guid,string,DateTimeOffset?,DateTimeOffset?,RequestContext)']/*" />
        public virtual async Task<Response> GetChartByReportNameAsync(Guid customerId, Guid searchIndexId, string reportName, DateTimeOffset? dateFrom = null, DateTimeOffset? dateTo = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(reportName, nameof(reportName));

            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetChartByReportName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetChartByReportNameRequest(customerId, searchIndexId, reportName, dateFrom, dateTo, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="reportName"> The String to use. </param>
        /// <param name="dateFrom"> The DateTimeISO8601 to use. </param>
        /// <param name="dateTo"> The DateTimeISO8601 to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="reportName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="reportName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetChartByReportName(Guid,Guid,string,DateTimeOffset?,DateTimeOffset?,RequestContext)']/*" />
        public virtual Response GetChartByReportName(Guid customerId, Guid searchIndexId, string reportName, DateTimeOffset? dateFrom = null, DateTimeOffset? dateTo = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(reportName, nameof(reportName));

            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetChartByReportName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetChartByReportNameRequest(customerId, searchIndexId, reportName, dateFrom, dateTo, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="reportName"> The String to use. </param>
        /// <param name="dateFrom"> The DateTimeISO8601 to use. </param>
        /// <param name="dateTo"> The DateTimeISO8601 to use. </param>
        /// <param name="includePreviousPeriod"> The Boolean to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="reportName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="reportName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetTileByReportNameAsync(Guid,Guid,string,DateTimeOffset?,DateTimeOffset?,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetTileByReportNameAsync(Guid customerId, Guid searchIndexId, string reportName, DateTimeOffset? dateFrom = null, DateTimeOffset? dateTo = null, bool? includePreviousPeriod = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(reportName, nameof(reportName));

            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetTileByReportName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTileByReportNameRequest(customerId, searchIndexId, reportName, dateFrom, dateTo, includePreviousPeriod, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="reportName"> The String to use. </param>
        /// <param name="dateFrom"> The DateTimeISO8601 to use. </param>
        /// <param name="dateTo"> The DateTimeISO8601 to use. </param>
        /// <param name="includePreviousPeriod"> The Boolean to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="reportName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="reportName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetTileByReportName(Guid,Guid,string,DateTimeOffset?,DateTimeOffset?,bool?,RequestContext)']/*" />
        public virtual Response GetTileByReportName(Guid customerId, Guid searchIndexId, string reportName, DateTimeOffset? dateFrom = null, DateTimeOffset? dateTo = null, bool? includePreviousPeriod = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(reportName, nameof(reportName));

            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetTileByReportName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTileByReportNameRequest(customerId, searchIndexId, reportName, dateFrom, dateTo, includePreviousPeriod, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetLatestSearchInterfaceAsync(Guid,Guid,RequestContext)']/*" />
        public virtual async Task<Response> GetLatestSearchInterfaceAsync(Guid customerId, Guid searchIndexId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetLatestSearchInterface");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLatestSearchInterfaceRequest(customerId, searchIndexId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetLatestSearchInterface(Guid,Guid,RequestContext)']/*" />
        public virtual Response GetLatestSearchInterface(Guid customerId, Guid searchIndexId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetLatestSearchInterface");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLatestSearchInterfaceRequest(customerId, searchIndexId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "text/json". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='CreateSearchInterfaceAsync(Guid,Guid,RequestContent,ContentType,RequestContext)']/*" />
        public virtual async Task<Response> CreateSearchInterfaceAsync(Guid customerId, Guid searchIndexId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.CreateSearchInterface");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateSearchInterfaceRequest(customerId, searchIndexId, content, contentType, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "text/json". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='CreateSearchInterface(Guid,Guid,RequestContent,ContentType,RequestContext)']/*" />
        public virtual Response CreateSearchInterface(Guid customerId, Guid searchIndexId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.CreateSearchInterface");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateSearchInterfaceRequest(customerId, searchIndexId, content, contentType, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetStatusAsync(RequestContext)']/*" />
        public virtual async Task<Response> GetStatusAsync(RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetStatusRequest(context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetStatus(RequestContext)']/*" />
        public virtual Response GetStatus(RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetStatusRequest(context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetSynonymsAsync(Guid,Guid,RequestContext)']/*" />
        public virtual async Task<Response> GetSynonymsAsync(Guid customerId, Guid searchIndexId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetSynonyms");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSynonymsRequest(customerId, searchIndexId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetSynonyms(Guid,Guid,RequestContext)']/*" />
        public virtual Response GetSynonyms(Guid customerId, Guid searchIndexId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetSynonyms");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSynonymsRequest(customerId, searchIndexId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "text/json". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='CreateSynonymAsync(Guid,Guid,RequestContent,ContentType,RequestContext)']/*" />
        public virtual async Task<Response> CreateSynonymAsync(Guid customerId, Guid searchIndexId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.CreateSynonym");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateSynonymRequest(customerId, searchIndexId, content, contentType, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "text/json". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='CreateSynonym(Guid,Guid,RequestContent,ContentType,RequestContext)']/*" />
        public virtual Response CreateSynonym(Guid customerId, Guid searchIndexId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.CreateSynonym");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateSynonymRequest(customerId, searchIndexId, content, contentType, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="synonymId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetSynonymByIdAsync(Guid,Guid,Guid,RequestContext)']/*" />
        public virtual async Task<Response> GetSynonymByIdAsync(Guid customerId, Guid searchIndexId, Guid synonymId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetSynonymById");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSynonymByIdRequest(customerId, searchIndexId, synonymId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="synonymId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetSynonymById(Guid,Guid,Guid,RequestContext)']/*" />
        public virtual Response GetSynonymById(Guid customerId, Guid searchIndexId, Guid synonymId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetSynonymById");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSynonymByIdRequest(customerId, searchIndexId, synonymId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="synonymId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='DeleteSynonymAsync(Guid,Guid,Guid,RequestContext)']/*" />
        public virtual async Task<Response> DeleteSynonymAsync(Guid customerId, Guid searchIndexId, Guid synonymId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.DeleteSynonym");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteSynonymRequest(customerId, searchIndexId, synonymId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="synonymId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='DeleteSynonym(Guid,Guid,Guid,RequestContext)']/*" />
        public virtual Response DeleteSynonym(Guid customerId, Guid searchIndexId, Guid synonymId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.DeleteSynonym");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteSynonymRequest(customerId, searchIndexId, synonymId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="synoynmId"> The Guid to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "text/json". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='UpdateSynonymAsync(Guid,Guid,Guid,RequestContent,ContentType,RequestContext)']/*" />
        public virtual async Task<Response> UpdateSynonymAsync(Guid customerId, Guid searchIndexId, Guid synoynmId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.UpdateSynonym");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateSynonymRequest(customerId, searchIndexId, synoynmId, content, contentType, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="synoynmId"> The Guid to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "text/json". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='UpdateSynonym(Guid,Guid,Guid,RequestContent,ContentType,RequestContext)']/*" />
        public virtual Response UpdateSynonym(Guid customerId, Guid searchIndexId, Guid synoynmId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.UpdateSynonym");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateSynonymRequest(customerId, searchIndexId, synoynmId, content, contentType, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="themeId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetThemeByIdAsync(Guid,Guid,Guid,RequestContext)']/*" />
        public virtual async Task<Response> GetThemeByIdAsync(Guid customerId, Guid searchIndexId, Guid themeId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetThemeById");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetThemeByIdRequest(customerId, searchIndexId, themeId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="themeId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetThemeById(Guid,Guid,Guid,RequestContext)']/*" />
        public virtual Response GetThemeById(Guid customerId, Guid searchIndexId, Guid themeId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetThemeById");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetThemeByIdRequest(customerId, searchIndexId, themeId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetThemeBySearchIndexIdAsync(Guid,Guid,RequestContext)']/*" />
        public virtual async Task<Response> GetThemeBySearchIndexIdAsync(Guid customerId, Guid searchIndexId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetThemeBySearchIndexId");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetThemeBySearchIndexIdRequest(customerId, searchIndexId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetThemeBySearchIndexId(Guid,Guid,RequestContext)']/*" />
        public virtual Response GetThemeBySearchIndexId(Guid customerId, Guid searchIndexId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetThemeBySearchIndexId");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetThemeBySearchIndexIdRequest(customerId, searchIndexId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The String to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="searchIndexId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="searchIndexId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetThemesByCustomerIdAsync(Guid,string,RequestContext)']/*" />
        public virtual async Task<Response> GetThemesByCustomerIdAsync(Guid customerId, string searchIndexId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(searchIndexId, nameof(searchIndexId));

            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetThemesByCustomerId");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetThemesByCustomerIdRequest(customerId, searchIndexId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The String to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="searchIndexId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="searchIndexId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='GetThemesByCustomerId(Guid,string,RequestContext)']/*" />
        public virtual Response GetThemesByCustomerId(Guid customerId, string searchIndexId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(searchIndexId, nameof(searchIndexId));

            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.GetThemesByCustomerId");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetThemesByCustomerIdRequest(customerId, searchIndexId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "text/json". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='UpdateThemeAsync(Guid,Guid,RequestContent,ContentType,RequestContext)']/*" />
        public virtual async Task<Response> UpdateThemeAsync(Guid customerId, Guid searchIndexId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.UpdateTheme");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateThemeRequest(customerId, searchIndexId, content, contentType, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="customerId"> The Guid to use. </param>
        /// <param name="searchIndexId"> The Guid to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "text/json". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/S2SearchAPIClient.xml" path="doc/members/member[@name='UpdateTheme(Guid,Guid,RequestContent,ContentType,RequestContext)']/*" />
        public virtual Response UpdateTheme(Guid customerId, Guid searchIndexId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("S2SearchAPIClient.UpdateTheme");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateThemeRequest(customerId, searchIndexId, content, contentType, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateGetConfigRequest(Guid searchIndexId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200404500);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/config/", false);
            uri.AppendPath(searchIndexId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        internal HttpMessage CreateUpdateConfigRequest(RequestContent content, ContentType contentType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200400404500);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/config/update", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            request.Headers.Add("Content-Type", contentType.ToString());
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetSearchIndexQueryCredentialsRequest(string customerEndpoint, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200404500);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/Configuration/queryCredentials/", false);
            uri.AppendPath(customerEndpoint, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        internal HttpMessage CreateGetThemeRequest(string customerEndpoint, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200404500);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/Configuration/theme/", false);
            uri.AppendPath(customerEndpoint, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        internal HttpMessage CreateGetSearchConfigurationRequest(string customerEndpoint, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200404500);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/Configuration/search/", false);
            uri.AppendPath(customerEndpoint, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        internal HttpMessage CreateGetGenericSynonymsRequest(string category, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200404500);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/Configuration/search/GenericSynonyms/", false);
            uri.AppendPath(category, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        internal HttpMessage CreateGetCustomerRequest(Guid customerId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200404500);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        internal HttpMessage CreateGetCustomerAndSearchIndexesRequest(Guid customerId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200404500);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchIndexes", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        internal HttpMessage CreateGetDashboardSummaryRequest(Guid customerId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200500);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/dashboard/summary", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        internal HttpMessage CreateCreateUserRequest(Guid customerId, Guid searchIndexId, RequestContent content, ContentType contentType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202400500);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            uri.AppendPath("/feedcredentials/user", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            request.Headers.Add("Content-Type", contentType.ToString());
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteUserRequest(Guid customerId, Guid searchIndexId, string username, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202400404500);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            uri.AppendPath("/feedcredentials/user/", false);
            uri.AppendPath(username, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        internal HttpMessage CreateUpdateUserStatusRequest(Guid customerId, Guid searchIndexId, RequestContent content, ContentType contentType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202400404500);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            uri.AppendPath("/feedcredentials/userStatus", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            request.Headers.Add("Content-Type", contentType.ToString());
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateUpdateUserPasswordRequest(Guid customerId, Guid searchIndexId, RequestContent content, ContentType contentType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202400404500);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            uri.AppendPath("/feedcredentials/userPassword", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            request.Headers.Add("Content-Type", contentType.ToString());
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetCredentialsRequest(Guid customerId, Guid searchIndexId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200400404500);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            uri.AppendPath("/feedcredentials/credentials", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        internal HttpMessage CreateGetLatestFeedConfigurationRequest(Guid customerId, Guid searchIndexId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200404500);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            uri.AppendPath("/feeds/latest", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        internal HttpMessage CreateSaveFeedConfigurationRequest(Guid customerId, Guid searchIndexId, RequestContent content, ContentType contentType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier201400500);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            uri.AppendPath("/feeds/create", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            request.Headers.Add("Content-Type", contentType.ToString());
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateUploadFeedFileRequest(Guid customerId, Guid searchIndexId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202400500);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            uri.AppendPath("/feeds/upload", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            request.Headers.Add("Content-Type", "multipart/form-data");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetKeysRequest(Guid customerId, Guid searchIndexId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200500);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            uri.AppendPath("/keys/all", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        internal HttpMessage CreateCreateKeysRequest(Guid customerId, Guid searchIndexId, RequestContent content, ContentType contentType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202400500);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            uri.AppendPath("/keys/create", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            request.Headers.Add("Content-Type", contentType.ToString());
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteKeysRequest(Guid customerId, Guid searchIndexId, RequestContent content, ContentType contentType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202500);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            uri.AppendPath("/keys", false);
            request.Uri = uri;
            request.Headers.Add("Content-Type", contentType.ToString());
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetNotificationRulesRequest(Guid customerId, Guid searchIndexId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200500);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            uri.AppendPath("/notificationrules", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        internal HttpMessage CreateCreateNotificationRuleRequest(Guid customerId, Guid searchIndexId, RequestContent content, ContentType contentType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier201400500);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            uri.AppendPath("/notificationrules", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            request.Headers.Add("Content-Type", contentType.ToString());
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetNotificationRuleByIdRequest(Guid customerId, Guid searchIndexId, int notificationRuleId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200404500);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            uri.AppendPath("/notificationrules/", false);
            uri.AppendPath(notificationRuleId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        internal HttpMessage CreateDeleteNotificationRuleRequest(Guid customerId, Guid searchIndexId, int notificationRuleId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204500);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            uri.AppendPath("/notificationrules/", false);
            uri.AppendPath(notificationRuleId, true);
            request.Uri = uri;
            return message;
        }

        internal HttpMessage CreateGetNotificationsRequest(Guid customerId, Guid searchIndexId, int? page, int? pageSize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200500);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            uri.AppendPath("/notifications", false);
            if (page != null)
            {
                uri.AppendQuery("page", page.Value, true);
            }
            if (pageSize != null)
            {
                uri.AppendQuery("pageSize", pageSize.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        internal HttpMessage CreateQueryCredentialsRequest(string customerEndpoint, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200404500);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/QueryCredentials/endpoint/", false);
            uri.AppendPath(customerEndpoint, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        internal HttpMessage CreateGetSearchIndexRequest(Guid customerId, Guid searchIndexId, bool? fullResource, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200404500);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            if (fullResource != null)
            {
                uri.AppendQuery("fullResource", fullResource.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        internal HttpMessage CreateDeleteSearchIndexRequest(Guid customerId, Guid searchIndexId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202404500);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        internal HttpMessage CreateGetSearchIndexByNameRequest(Guid customerId, string friendlyName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200404500);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/name/", false);
            uri.AppendPath(friendlyName, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        internal HttpMessage CreateGetSearchIndexPricingRequest(Guid customerId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200500);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/pricing", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        internal HttpMessage CreateCreateSearchIndexRequest(Guid customerId, RequestContent content, ContentType contentType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202409);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/create", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            request.Headers.Add("Content-Type", contentType.ToString());
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetSearchInsightsSummaryRequest(Guid customerId, Guid searchIndexId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200404500);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            uri.AppendPath("/searchinsights/summary", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        internal HttpMessage CreateGetChartByReportNameRequest(Guid customerId, Guid searchIndexId, string reportName, DateTimeOffset? dateFrom, DateTimeOffset? dateTo, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200404500);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            uri.AppendPath("/searchinsights/chart/", false);
            uri.AppendPath(reportName, true);
            if (dateFrom != null)
            {
                uri.AppendQuery("dateFrom", dateFrom.Value, "O", true);
            }
            if (dateTo != null)
            {
                uri.AppendQuery("dateTo", dateTo.Value, "O", true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        internal HttpMessage CreateGetTileByReportNameRequest(Guid customerId, Guid searchIndexId, string reportName, DateTimeOffset? dateFrom, DateTimeOffset? dateTo, bool? includePreviousPeriod, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200404500);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            uri.AppendPath("/searchinsights/tile/", false);
            uri.AppendPath(reportName, true);
            if (dateFrom != null)
            {
                uri.AppendQuery("dateFrom", dateFrom.Value, "O", true);
            }
            if (dateTo != null)
            {
                uri.AppendQuery("dateTo", dateTo.Value, "O", true);
            }
            if (includePreviousPeriod != null)
            {
                uri.AppendQuery("includePreviousPeriod", includePreviousPeriod.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        internal HttpMessage CreateGetLatestSearchInterfaceRequest(Guid customerId, Guid searchIndexId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200404500);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            uri.AppendPath("/searchinterfaces/latest", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        internal HttpMessage CreateCreateSearchInterfaceRequest(Guid customerId, Guid searchIndexId, RequestContent content, ContentType contentType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier201400500);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            uri.AppendPath("/searchinterfaces", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            request.Headers.Add("Content-Type", contentType.ToString());
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetStatusRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/Status", false);
            request.Uri = uri;
            return message;
        }

        internal HttpMessage CreateGetSynonymsRequest(Guid customerId, Guid searchIndexId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200500);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            uri.AppendPath("/synonyms", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        internal HttpMessage CreateCreateSynonymRequest(Guid customerId, Guid searchIndexId, RequestContent content, ContentType contentType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier201400409500);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            uri.AppendPath("/synonyms", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            request.Headers.Add("Content-Type", contentType.ToString());
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetSynonymByIdRequest(Guid customerId, Guid searchIndexId, Guid synonymId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200404500);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            uri.AppendPath("/synonyms/", false);
            uri.AppendPath(synonymId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        internal HttpMessage CreateDeleteSynonymRequest(Guid customerId, Guid searchIndexId, Guid synonymId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204404500);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            uri.AppendPath("/synonyms/", false);
            uri.AppendPath(synonymId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        internal HttpMessage CreateUpdateSynonymRequest(Guid customerId, Guid searchIndexId, Guid synoynmId, RequestContent content, ContentType contentType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier201400404500);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            uri.AppendPath("/synonyms/", false);
            uri.AppendPath(synoynmId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            request.Headers.Add("Content-Type", contentType.ToString());
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetThemeByIdRequest(Guid customerId, Guid searchIndexId, Guid themeId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200404500);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            uri.AppendPath("/theme/", false);
            uri.AppendPath(themeId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        internal HttpMessage CreateGetThemeBySearchIndexIdRequest(Guid customerId, Guid searchIndexId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200404500);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            uri.AppendPath("/theme", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        internal HttpMessage CreateGetThemesByCustomerIdRequest(Guid customerId, string searchIndexId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200404500);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            uri.AppendPath("/theme/all", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            return message;
        }

        internal HttpMessage CreateUpdateThemeRequest(Guid customerId, Guid searchIndexId, RequestContent content, ContentType contentType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200400404500);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/api/customers/", false);
            uri.AppendPath(customerId, true);
            uri.AppendPath("/searchindex/", false);
            uri.AppendPath(searchIndexId, true);
            uri.AppendPath("/theme/update", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json, text/json");
            request.Headers.Add("Content-Type", contentType.ToString());
            request.Content = content;
            return message;
        }

        private static ResponseClassifier _responseClassifier200404500;
        private static ResponseClassifier ResponseClassifier200404500 => _responseClassifier200404500 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 404, 500 });
        private static ResponseClassifier _responseClassifier200400404500;
        private static ResponseClassifier ResponseClassifier200400404500 => _responseClassifier200400404500 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 400, 404, 500 });
        private static ResponseClassifier _responseClassifier200500;
        private static ResponseClassifier ResponseClassifier200500 => _responseClassifier200500 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 500 });
        private static ResponseClassifier _responseClassifier202400500;
        private static ResponseClassifier ResponseClassifier202400500 => _responseClassifier202400500 ??= new StatusCodeClassifier(stackalloc ushort[] { 202, 400, 500 });
        private static ResponseClassifier _responseClassifier202400404500;
        private static ResponseClassifier ResponseClassifier202400404500 => _responseClassifier202400404500 ??= new StatusCodeClassifier(stackalloc ushort[] { 202, 400, 404, 500 });
        private static ResponseClassifier _responseClassifier201400500;
        private static ResponseClassifier ResponseClassifier201400500 => _responseClassifier201400500 ??= new StatusCodeClassifier(stackalloc ushort[] { 201, 400, 500 });
        private static ResponseClassifier _responseClassifier202500;
        private static ResponseClassifier ResponseClassifier202500 => _responseClassifier202500 ??= new StatusCodeClassifier(stackalloc ushort[] { 202, 500 });
        private static ResponseClassifier _responseClassifier204500;
        private static ResponseClassifier ResponseClassifier204500 => _responseClassifier204500 ??= new StatusCodeClassifier(stackalloc ushort[] { 204, 500 });
        private static ResponseClassifier _responseClassifier202404500;
        private static ResponseClassifier ResponseClassifier202404500 => _responseClassifier202404500 ??= new StatusCodeClassifier(stackalloc ushort[] { 202, 404, 500 });
        private static ResponseClassifier _responseClassifier202409;
        private static ResponseClassifier ResponseClassifier202409 => _responseClassifier202409 ??= new StatusCodeClassifier(stackalloc ushort[] { 202, 409 });
        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier201400409500;
        private static ResponseClassifier ResponseClassifier201400409500 => _responseClassifier201400409500 ??= new StatusCodeClassifier(stackalloc ushort[] { 201, 400, 409, 500 });
        private static ResponseClassifier _responseClassifier204404500;
        private static ResponseClassifier ResponseClassifier204404500 => _responseClassifier204404500 ??= new StatusCodeClassifier(stackalloc ushort[] { 204, 404, 500 });
        private static ResponseClassifier _responseClassifier201400404500;
        private static ResponseClassifier ResponseClassifier201400404500 => _responseClassifier201400404500 ??= new StatusCodeClassifier(stackalloc ushort[] { 201, 400, 404, 500 });
    }
}
